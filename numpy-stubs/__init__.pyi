"""Public API of numpy"""
from typing import (
    Any,
    Callable,
    Dict,
    Generic,
    Iterator,
    IO,
    List,
    Optional,
    Sequence,
    Tuple,
    Type,
    TypeVar,
    Union,
    overload,
    Iterable,
)
from typing_extensions import Protocol, Literal
from pathlib import Path
import builtins

from . import testing, random, ma, linalg

from pandas import Series

_T = TypeVar("_T")

_Scalar = TypeVar("_Scalar", bound=void)
_Scalar2 = TypeVar("_Scalar2", bound=void)

# void is the base class of all the types that an ndarray can have
class void:
    @property
    def dtype(self: _Scalar) -> _dtype[_Scalar]: ...
    def astype(self, dtype: Type[_Scalar]) -> _Scalar: ...
    def copy(self: _Scalar) -> _Scalar: ...

# a smaller-bit integer can act like a bigger integer in the sense that if you add an int16 and an
# int64, then numpy will upgrade the int16 to an int64 and add them
# and this is why we let int32 be a subclass of int64; and similarly for float32 and float64
# the same logic applies when adding unsigned and signed values (uint + int -> int)
class float64(void): ...
class float32(float64): ...
class float16(float32): ...

class int64(float64): ...
class int32(int64, float64): ...
class int16(int32, float32): ...
class int8(int16, float16): ...
class uint64(int64): ...
class uint32(uint64, int32): ...
class uint16(uint32, int16): ...
class uint8(uint16, int8): ...
class bool_(int8): ...
class str_(void, str): ...
class object_(void): ...

# type aliases
generic = void
number = float64
floating = float64
integer = int64

# _Scalar = TypeVar(
#     "_Scalar",
#     bool_,
#     float16,
#     float32,
#     float64,
#     int8,
#     int16,
#     int32,
#     int64,
#     str_,
#     uint8,
#     uint16,
#     uint32,
#     uint64,
#     covariant=True,
# )
# _Scalar2 = TypeVar(
#     "_Scalar2",
#     bool_,
#     float16,
#     float32,
#     float64,
#     int8,
#     int16,
#     int32,
#     int64,
#     str_,
#     uint8,
#     uint16,
#     uint32,
#     uint64,
#     covariant=True,
# )
_ScalarObj = TypeVar("_ScalarObj", bound=Union[void, int, float])
_ShapeType = Union[int, Tuple[int, ...], List[int]]
_AxesType = Union[int, Tuple[int, ...], List[int]]
_InterpolationType = Literal["linear", "lower", "higher", "midpoint", "nearest"]
_OrderType = Union[str, Sequence[str]]
_ScalarLike = Union[_Scalar, str, int, float]
_ConditionType = Union[ndarray[bool_], bool_, bool]
newaxis: None = ...

_AnyNum = Union[int, float, bool]
# generic types that are only allowed to take on dtype values

_Float = TypeVar("_Float", float16, float32, float64)
_FloatObj = TypeVar("_FloatObj", bound=Union[floating, float])
_Int = TypeVar("_Int", bool_, int8, int16, int32, int64, uint8, uint16, uint32, uint64)
_IntObj = TypeVar("_IntObj", bound=Union[integer, int])
_BoolObj = TypeVar("_BoolObj", bound=Union[bool_, bool])

_NestedList = Union[List[_T], List[List[_T]], List[List[List[_T]]], List[List[List[List[_T]]]]]

class dtype(Generic[_Scalar]):
    @overload
    def __init__(self: dtype[_Scalar], obj: Type[_Scalar]) -> None: ...
    @overload
    def __init__(self: dtype[int8], obj: Literal["int8"]) -> None: ...
    @overload
    def __init__(self: dtype[int16], obj: Literal["int16"]) -> None: ...
    @overload
    def __init__(self: dtype[int32], obj: Literal["int32"]) -> None: ...
    @property
    def type(self) -> Type[_Scalar]: ...

_dtype = dtype

class ndarray(Generic[_Scalar]):
    """
    The main object in the numpy library.
    """

    #
    # Array-like structures attributes
    #
    dtype: _dtype[_Scalar]
    size: int
    ndim: int
    shape: Tuple[int, ...]

    #
    # Array-like methods
    #
    def __init__(
        self,
        shape: Tuple[int, ...],
        dtype: Optional[Type[_Scalar]] = ...,
        buffer: Optional[Any] = ...,
        offset: Optional[int] = ...,
        strides: Optional[Tuple[int, ...]] = ...,
        order: Optional[str] = ...,
    ) -> None: ...
    def all(self, axis: Optional[_AxesType] = ..., keepdims: bool = ...) -> ndarray[_Scalar]: ...
    def any(self, axis: Optional[_AxesType] = ..., keepdims: bool = ...) -> ndarray[_Scalar]: ...
    def argmax(self, axis: Optional[int] = ...) -> ndarray[_Scalar]: ...
    def argmin(self, axis: Optional[int] = ...) -> ndarray[_Scalar]: ...
    # def argpartition(self, kth: Union[int, Sequence[int]], axis: Optional[int]=-1,
    #                  kind: str='introselect', order: _OrderType=None) -> ndarray[_Scalar]: ...
    def argsort(
        self, axis: Optional[int] = ..., kind: str = ..., order: Optional[_OrderType] = ...
    ) -> ndarray[_Scalar]: ...
    # _Scalar has to be split up like this for some reason; I don't fully understand it
    @overload
    def astype(self, dtype: Type[_Int], copy: bool = ...) -> ndarray[_Int]: ...
    @overload
    def astype(self, dtype: Type[_Float], copy: bool = ...) -> ndarray[_Float]: ...
    @overload
    def astype(self, dtype: Type[str_], copy: bool = ...) -> ndarray[str_]: ...
    # the bool overload has to come before the int overload because bool is a subclass of int
    @overload
    def astype(self, dtype: Type[bool], copy: bool = ...) -> ndarray[bool_]: ...
    @overload
    def astype(self, dtype: Type[int], copy: bool = ...) -> ndarray[int64]: ...
    @overload
    def astype(self, dtype: Type[float], copy: bool = ...) -> ndarray[float64]: ...
    @overload
    def astype(self, dtype: Type[str], copy: bool = ...) -> ndarray[str_]: ...
    def byteswap(self, inplace: bool = ...) -> ndarray[_Scalar]: ...
    def choose(self, choices: Sequence[ndarray[_Scalar]], mode: str = ...) -> ndarray[_Scalar]: ...
    def clip(self, a_min: _AnyNum, a_max: _AnyNum) -> ndarray[_Scalar]: ...
    def compress(self, condition: Sequence[bool], axis: Optional[int] = ...) -> ndarray[_Scalar]: ...
    def conj(self) -> ndarray[_Scalar]: ...
    def conjugate(self) -> ndarray[_Scalar]: ...
    def copy(self, order: str = ...) -> ndarray[_Scalar]: ...
    def cumprod(self, axis: Optional[int] = ..., dtype: Optional[Any] = ...) -> ndarray[_Scalar]: ...
    def cumsum(
        self, axis: Optional[int] = ..., dtype: Optional[Type[_Scalar]] = ...
    ) -> ndarray[_Scalar]: ...
    def diagonal(
        self, offset: int = ..., axis1: int = ..., axis2: int = ...
    ) -> ndarray[_Scalar]: ...
    def dot(self, b: ndarray[_Scalar]) -> ndarray[_Scalar]: ...
    def dump(self, file: str) -> None: ...
    def dumps(self) -> str: ...
    # def fill(self, value: _S) -> None: ...
    def flatten(self, order: str = ...) -> ndarray[_Scalar]: ...
    def getfield(self, dtype: Type[_Scalar], offset: int = ...) -> ndarray[_Scalar]: ...
    def item(self) -> _Scalar: ...
    def itemset(self, arg0: Union[int, Tuple[int, ...]], arg1: Optional[Any] = ...) -> None: ...
    def max(self) -> _Scalar: ...
    @overload
    def mean(self: ndarray[float32]) -> float32: ...
    @overload
    def mean(self: ndarray[float32], axis: _AxesType) -> ndarray[float32]: ...
    @overload
    def mean(self) -> float64: ...
    @overload
    def mean(self, axis: _AxesType) -> ndarray[float64]: ...
    def min(self) -> _Scalar: ...
    def newbyteorder(self, new_order: str = ...) -> ndarray[_Scalar]: ...
    def nonzero(self) -> Tuple[ndarray[int64], ...]: ...
    def partition(
        self, kth: _AxesType, axis: int = ..., kind: str = ..., order: Optional[_OrderType] = ...
    ) -> None: ...
    def prod(
        self,
        axis: Optional[_AxesType] = ...,
        dtype: Optional[Type[_Scalar]] = ...,
        keepdims: bool = ...,
    ) -> ndarray[_Scalar]: ...
    def ptp(self, axis: Optional[int] = ...) -> ndarray[_Scalar]: ...
    def put(self, ind: ndarray[_Scalar], v: ndarray[_Scalar], mode: str = ...) -> None: ...
    def ravel(self, order: str = ...) -> ndarray[_Scalar]: ...
    def repeat(
        self, repeats: Union[int, Sequence[int]], axis: Optional[int] = ...
    ) -> ndarray[_Scalar]: ...
    @overload
    def reshape(self, *newshape: int) -> ndarray[_Scalar]: ...
    @overload
    def reshape(
        self, newshape: Union[Tuple[int, ...], List[int]], order: str = ...
    ) -> ndarray[_Scalar]: ...
    def resize(self, new_shape: _ShapeType, refcheck: bool = ...) -> None: ...
    def round(self, decimals: int = ...) -> ndarray[_Scalar]: ...
    # def searchsorted(self, v: Union[_S, ndarray[_Scalar]], side: str='left',
    #                  sorter: ndarray[_Scalar]=None) -> ndarray[_Scalar]: ...
    def setfield(self, val: Any, dtype: Type[_Scalar], offset: int = ...) -> None: ...
    def setflags(
        self, write: Optional[bool] = ..., align: Optional[bool] = ..., uic: Optional[bool] = ...
    ) -> None: ...
    def sort(self, axis: int = ..., kind: str = ..., order: Optional[_OrderType] = ...) -> None: ...
    def squeeze(self, axis: Optional[_AxesType] = ...) -> ndarray[_Scalar]: ...
    @overload
    def std(self: ndarray[float32]) -> float32: ...
    @overload
    def std(self) -> float64: ...
    @overload
    def std(
        self,
        axis: _AxesType,
        dtype: Optional[Type[_Scalar]] = ...,
        ddof: int = ...,
        keepdims: bool = ...,
    ) -> ndarray[_Scalar]: ...
    @overload
    def sum(self) -> _Scalar: ...
    @overload
    def sum(self, axis: Optional[_AxesType], keepdims: bool = ...) -> ndarray[_Scalar]: ...
    def swapaxes(self, axis1: int, axis2: int) -> ndarray[_Scalar]: ...
    def take(
        self, indices: Sequence[int], axis: Optional[int] = ..., mode: str = ...
    ) -> ndarray[_Scalar]: ...
    def tobytes(self, order: str = ...) -> bytes: ...
    def tofile(
        self,
        fid: object,
        sep: str = ...,  # TODO fix fid definition (There's a bug in mypy io's namespace https://github.com/python/mypy/issues/1462)
        format: str = ...,
    ) -> None: ...
    # for some reason, you can not use _Float to narrow down the type of ndarray here:
    @overload
    def tolist(
        self: Union[ndarray[bool_], ndarray[int8], ndarray[int16], ndarray[int32], ndarray[int64]]
    ) -> Sequence[int]: ...
    @overload
    def tolist(self: Union[ndarray[float32], ndarray[float64]]) -> Sequence[float]: ...
    @overload
    def tolist(self: ndarray[str_]) -> Sequence[str]: ...
    def tostring(self, order: str = ...) -> bytes: ...
    def trace(
        self,
        offset: int = ...,
        axis1: int = ...,
        axis2: int = ...,
        dtype: Optional[Type[_Scalar]] = ...,
    ) -> ndarray[_Scalar]: ...
    def transpose(self, axes: Optional[_AxesType] = ...) -> ndarray[_Scalar]: ...
    def var(
        self,
        axis: Optional[_AxesType] = ...,
        dtype: Optional[Type[_Scalar]] = ...,
        ddof: int = ...,
        keepdims: bool = ...,
    ) -> ndarray[_Scalar]: ...
    def view(
        self,
        dtype: Optional[Union[Type[_Scalar], Type[ndarray[_Scalar]]]] = ...,
        type: Optional[type] = ...,
    ) -> ndarray[_Scalar]: ...
    #
    # Magic methods
    #
    def __abs__(self) -> ndarray[_Scalar]: ...
    @overload
    def __add__(self, value: ndarray[_Scalar]) -> ndarray[_Scalar]: ...
    @overload
    def __add__(self, value: _Scalar) -> ndarray[_Scalar]: ...
    def __and__(self, value: object) -> ndarray[_Scalar]: ...
    @overload
    def __array__(self) -> ndarray[_Scalar]: ...
    @overload
    def __array__(self, dtype: Type[_Scalar2]) -> ndarray[_Scalar2]: ...
    def __array_prepare__(self, context: Optional[object] = ...) -> ndarray[_Scalar]: ...
    def __array_wrap__(self, context: Optional[object] = ...) -> ndarray[_Scalar]: ...
    def __bool__(self) -> bool: ...
    def __complex__(self) -> complex: ...
    def __contains__(self, key: object) -> bool: ...
    def __copy__(self) -> ndarray[_Scalar]: ...
    def __deepcopy__(self) -> ndarray[_Scalar]: ...
    def __delattr__(self, name: str) -> None: ...
    def __delitem__(self, key: str) -> None: ...
    def __dir__(self) -> List[str]: ...
    def __divmod__(self, value: object) -> Tuple[ndarray[_Scalar], ndarray[_Scalar]]: ...
    def __eq__(self, value: object) -> ndarray[bool_]: ...  # type: ignore
    def __float__(self) -> float: ...
    def __floordiv__(self, value: object) -> ndarray[_Scalar]: ...
    def __ge__(self, value: object) -> ndarray[bool_]: ...
    def __getattribute__(self, name: str) -> Any: ...
    @overload
    def __getitem__(self, key: Union[int, Tuple[int, ...]]) -> _Scalar: ...
    @overload
    def __getitem__(
        self,
        key: Union[
            None,
            slice,
            str,
            ndarray[_Int],
            List[int],
            Tuple[int, Union[slice, ellipsis, None]],
            Tuple[Union[slice, ellipsis, None], int],
            Tuple[Union[slice, ellipsis, None], Union[slice, ellipsis, None], int],
            Tuple[Union[ndarray[_Int], slice, ellipsis, None], ...],
        ],
    ) -> ndarray[_Scalar]: ...
    def __gt__(self, value: object) -> ndarray[bool_]: ...
    @overload
    def __iadd__(self, value: ndarray[_Scalar]) -> ndarray[_Scalar]: ...
    @overload
    def __iadd__(self, value: _Scalar) -> ndarray[_Scalar]: ...
    def __iand__(self, value: object) -> ndarray[bool_]: ...
    def __ifloordiv__(self, value: object) -> None: ...
    def __ilshift__(self, value: object) -> None: ...
    def __imatmul__(self, value: ndarray[_Scalar]) -> None: ...
    def __imod__(self, value: object) -> None: ...
    def __imul__(self, value: object) -> None: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __invert__(self) -> ndarray[_Scalar]: ...
    def __ior__(self, value: object) -> None: ...
    def __ipow__(self, value: object) -> None: ...
    def __irshift__(self, value: object) -> None: ...
    def __isub__(self, value: object) -> None: ...
    def __iter__(self) -> Iterator[_Scalar]: ...
    def __itruediv__(self, value: object) -> ndarray[float64]: ...
    def __ixor__(self, value: object) -> None: ...
    def __le__(self, value: object) -> ndarray[_Scalar]: ...
    def __len__(self) -> int: ...
    def __lshift__(self, value: object) -> ndarray[_Scalar]: ...
    def __lt__(self, value: object) -> ndarray[_Scalar]: ...
    def __matmul__(self, value: ndarray[_Scalar]) -> ndarray[_Scalar]: ...
    def __mod__(self, value: object) -> ndarray[_Scalar]: ...
    def __mul__(self, value: object) -> ndarray[_Scalar]: ...
    def __ne__(self, value: object) -> ndarray[_Scalar]: ...  # type: ignore
    def __neg__(self) -> ndarray[_Scalar]: ...
    def __or__(self, value: object) -> ndarray[_Scalar]: ...
    def __pos__(self) -> ndarray[_Scalar]: ...
    def __pow__(self, value: object) -> ndarray[_Scalar]: ...
    @overload
    def __radd__(self, value: ndarray[_Scalar]) -> ndarray[_Scalar]: ...
    @overload
    def __radd__(self, value: _Scalar) -> ndarray[_Scalar]: ...
    def __rand__(self, value: object) -> ndarray[_Scalar]: ...
    def __rdivmod__(self, value: object) -> Tuple[ndarray[_Scalar], ndarray[_Scalar]]: ...
    def __rfloordiv__(self, value: object) -> ndarray[_Scalar]: ...
    def __rlshift__(self, value: object) -> ndarray[_Scalar]: ...
    def __rmatmul__(self, value: object) -> ndarray[_Scalar]: ...
    def __rmod__(self, value: object) -> ndarray[_Scalar]: ...
    def __rmul__(self, value: object) -> ndarray[_Scalar]: ...
    def __ror__(self, value: object) -> ndarray[_Scalar]: ...
    def __rpow__(self, value: object) -> ndarray[_Scalar]: ...
    def __rrshift__(self, value: object) -> ndarray[_Scalar]: ...
    def __rshift__(self, value: object) -> ndarray[_Scalar]: ...
    def __rsub__(self, value: object) -> ndarray[_Scalar]: ...
    @overload
    def __rtruediv__(
        self: ndarray[float32], value: Union[ndarray[float32], float32, float]
    ) -> ndarray[float32]: ...
    @overload
    def __rtruediv__(self, value: object) -> ndarray[float64]: ...
    def __rxor__(self, value: object) -> ndarray[_Scalar]: ...
    def __setattr__(self, name: str, value: Any) -> None: ...
    def __setitem__(self, key: Any, value: Any) -> None: ...
    def __str__(self) -> str: ...
    def __sub__(self, value: object) -> ndarray[_Scalar]: ...
    @overload
    def __truediv__(
        self: ndarray[float32], value: Union[ndarray[float32], float32, float]
    ) -> ndarray[float32]: ...
    @overload
    def __truediv__(self, value: object) -> ndarray[float64]: ...
    def __xor__(self, value: object) -> ndarray[_Scalar]: ...

class Array(Protocol[_Scalar]):
    def __array__(self) -> Union[ndarray[_Scalar], Sequence[Sequence[_Scalar]]]: ...

_ArrayLike = Union[Array[_Scalar], Sequence[_Scalar]]
_Coercable = Union[_ArrayLike, _ScalarObj]

######
# numpy's scalar hierarchy (http://docs.scipy.org/doc/numpy/reference/arrays.scalars.html#scalars)
######
# class bool_: ...
# class number: ...
# class integer(number, int): ...
# class signedinteger(integer): ...
# class byte(signedinteger): ...
# class short(signedinteger): ...
# class intc(signedinteger): ...
# class int_(signedinteger): ...
# class longlong(signedinteger): ...
# class int8(signedinteger): ...
# class int16(signedinteger): ...
# class int32(signedinteger): ...
# class int64(signedinteger): ...
# class unsignedinteger(integer): ...
# class ubyte(unsignedinteger): ...
# class ushort(unsignedinteger): ...
# class uintc(unsignedinteger): ...
# class uint(unsignedinteger): ...
# class ulonglong(unsignedinteger): ...
# class uint8(signedinteger): ...
# class uint16(signedinteger): ...
# class uint32(signedinteger): ...
# class uint64(signedinteger): ...
# class inexact(number[float]): ...
# class floating(inexact): ...
# class half(floating): ...
# class single(floating): ...
# class float_(floating): ...
# class longfloat_(floating): ...
# class float16(floating): ...
# class float64(floating): ...
# class float128(floating): ...
# class complexfloating(inexact): ...
# class csingle(complexfloating): ...
# class complex_(complexfloating): ...
# class clongfloat(complexfloating): ...
# class complex64(complexfloating): ...
# class complex128(complexfloating): ...
# class complex256(complexfloating): ...
# class flexible(generic[_Scalar], Generic[_Scalar]): ...
# class character(flexible[str]): ...
# class str_(character): ...
# class unicode_(character): ...
# class void(flexible[None]): ...

#
# Array creation routines
#
# np.array: first check if the dtype has been set explicitly
@overload
def array(
    object: Union[_NestedList[Any], Iterable[ndarray], ndarray], dtype: Type[_Scalar]
) -> ndarray[_Scalar]: ...
@overload
def array(
    object: Union[_NestedList[Any], Iterable[ndarray], ndarray], dtype: Type[int]
) -> ndarray[int64]: ...
@overload
def array(
    object: Union[_NestedList[Any], Iterable[ndarray], ndarray], dtype: Type[float]
) -> ndarray[float64]: ...

# np.array: then check if it is a list of some type. check the most specific first
@overload
def array(object: _NestedList[bool]) -> ndarray[bool_]: ...
@overload
def array(object: _NestedList[_Int]) -> ndarray[_Int]: ...
@overload
def array(object: _NestedList[_Float]) -> ndarray[_Float]: ...
@overload
def array(object: _NestedList[int]) -> ndarray[int64]: ...
@overload
def array(object: _NestedList[float]) -> ndarray[float64]: ...
@overload
def array(object: _NestedList[str]) -> ndarray[str_]: ...
@overload
def array(object: Union[ndarray[_Scalar], _NestedList[ndarray[_Scalar]]]) -> ndarray[_Scalar]: ...
@overload
def arange(stop: int, start: int = ..., step: int = ...) -> ndarray[int64]: ...
@overload
def arange(range_: int, dtype: Type[_Scalar]) -> ndarray[_Scalar]: ...
@overload
def arange(range_: float) -> ndarray[float64]: ...
def ascontiguousarray(a: Any, dtype: Optional[Type[_Scalar]] = ...) -> ndarray: ...
def copy(a: Any, order: Optional[str] = ...) -> ndarray: ...
def delete(
    arr: ndarray[_Scalar], object: Union[int, List[int], slice], axis: Optional[int] = ...
) -> ndarray[_Scalar]: ...
@overload
def empty(shape: _ShapeType, dtype: Type[_Int]) -> ndarray[_Int]: ...
@overload
def empty(shape: _ShapeType, dtype: Type[_Float]) -> ndarray[_Float]: ...
@overload
def empty(shape: _ShapeType, dtype: Type[str_]) -> ndarray[str_]: ...
@overload
def empty(shape: _ShapeType, dtype: Type[bool]) -> ndarray[bool_]: ...
@overload
def empty(shape: _ShapeType, dtype: Type[int]) -> ndarray[int64]: ...
@overload
def empty(shape: _ShapeType, dtype: Type[float] = ...) -> ndarray[float64]: ...
@overload
def empty(shape: _ShapeType, dtype: Type[str]) -> ndarray[str_]: ...
def empty_like(
    a: Any, dtype: Optional[Any] = ..., order: str = ..., subok: bool = ...
) -> ndarray: ...
def eye(N: int, M: Optional[int] = ..., k: int = ..., dtype: Type[_Scalar] = ...) -> ndarray: ...
def flatnonzero(a: ndarray[_Scalar]) -> ndarray[int64]: ...
def full(
    shape: _ShapeType, fill_value: Any, dtype: Optional[Type[_Scalar]] = ..., order: str = ...
) -> ndarray: ...
def full_like(
    a: Any,
    fill_value: Any,
    dtype: Optional[Type[_Scalar]] = ...,
    order: str = ...,
    subok: bool = ...,
) -> ndarray: ...

# def fromfunction(
#     function: Callable[..., _S], shape: _ShapeType, dtype: Type[_Scalar] = float
# ) -> ndarray[_S]: ...
def fromiter(iterable: Iterator, dytpe: Type[_Scalar], count: int = ...) -> ndarray: ...
def fromstring(
    string: str, dtype: Type[_Scalar] = ..., count: int = ..., sep: str = ...
) -> ndarray: ...
def histogramdd(
    a: ndarray,
    bins: Optional[Union[ndarray, Series, List, int]],
    range: Optional[List[Tuple[number, number]]] = ...,
    density: bool = ...,
    normed: bool = ...,
    weights: Optional[Union[ndarray, Series, List[number]]] = ...,
) -> Tuple[ndarray, List[number]]: ...
def identity(n: int, dtype: Optional[Type[_Scalar]] = ...) -> ndarray: ...
def insert(arr: ndarray[_Scalar], index: int, value: _Scalar) -> ndarray[_Scalar]: ...
@overload
def linspace(
    start: float, stop: float, num: int = ..., endpoint: bool = ...
) -> ndarray[float64]: ...
@overload
def linspace(
    start: float, stop: float, *, dtype: Type[_Scalar], num: int = ..., endpoint: bool = ...
) -> ndarray[_Scalar]: ...
def load(file: Union[Path, IO], encoding: str = ...) -> Dict[str, ndarray]: ...
def loadtxt(
    fname: Any,
    dtype: Type[_Scalar] = ...,
    comments: Union[str, Sequence[str]] = ...,
    delimiter: Optional[str] = ...,
    converters: Optional[Dict[int, Callable[[Any], float]]] = ...,
    skiprows: int = ...,
    usecols: Optional[Sequence[int]] = ...,
    unpack: bool = ...,
    ndmin: int = ...,
) -> ndarray: ...
@overload
def ones(shape: _ShapeType, order: str = ...) -> ndarray[float64]: ...
@overload
def ones(shape: _ShapeType, dtype: Type[_Scalar] = ..., order: str = ...) -> ndarray[_Scalar]: ...
@overload
def ones_like(a: ndarray[_Scalar], subok: bool = ...) -> ndarray[_Scalar]: ...
@overload
def ones_like(a: ndarray, dtype: Type[_Scalar], subok: bool = ...) -> ndarray[_Scalar]: ...
@overload
def repeat(a: _Scalar, repeats: _IntObj) -> ndarray[_Scalar]: ...
@overload
def repeat(a: int, repeats: _IntObj) -> ndarray[int64]: ...
@overload
def repeat(a: float, repeats: _IntObj) -> ndarray[float64]: ...
@overload
def repeat(a: ndarray[_Scalar], repeats: _IntObj) -> ndarray[_Scalar]: ...
@overload
def zeros(shape: _ShapeType, order: str = ...) -> ndarray[float64]: ...
@overload
def zeros(shape: _ShapeType, dtype: Type[_Scalar] = ..., order: str = ...) -> ndarray[_Scalar]: ...
@overload
def zeros_like(a: ndarray[_Scalar], order: str = ..., subok: bool = ...) -> ndarray[_Scalar]: ...
@overload
def zeros_like(a: ndarray, dtype: Type[_Scalar], subok: bool = ...) -> ndarray[_Scalar]: ...

#
# Array transformation routines
#
def abs(x: ndarray[_Scalar]) -> ndarray[_Scalar]: ...
def add(x1: ndarray[_Scalar], x2: ndarray[_Scalar]) -> ndarray[_Scalar]: ...
@overload
def all(a: ndarray[_Scalar]) -> bool_: ...
@overload
def all(a: ndarray[_Scalar], axis: _AxesType) -> ndarray[bool_]: ...
@overload
def amax(a: ndarray[_Scalar]) -> _Scalar: ...
@overload
def amax(a: ndarray[_Scalar], axis: _AxesType) -> ndarray[_Scalar]: ...
def append(a: _ArrayLike, b: _ArrayLike, axis: _AxesType = ...) -> ndarray: ...
@overload
def argmin(a: Sequence, axis: _AxesType = ...) -> int64: ...
@overload
def argmin(
    a: ndarray[_Scalar], axis: _AxesType = ..., out: Optional[ndarray[_Scalar]] = ...
) -> ndarray[int64]: ...
@overload
def argmax(a: Sequence, axis: _AxesType = ...) -> int64: ...
@overload
def argmax(
    a: ndarray[_Scalar], axis: _AxesType = ..., out: Optional[ndarray[_Scalar]] = ...
) -> ndarray[int64]: ...
def argsort(a: ndarray[_Scalar], axis: _AxesType = ...) -> ndarray[_Scalar]: ...
def array_equal(a1: ndarray[_Scalar], a2: ndarray[_Scalar]) -> bool: ...
def array_split(
    ary: ndarray[_Scalar], indices_or_sections: Union[int, List[int]], axis: int = ...
) -> List[ndarray[_Scalar]]: ...
def asscaler(x: _Int) -> int: ...

# np.asarray
@overload
def asarray(a: ndarray, dtype: Type[_Int]) -> ndarray[_Int]: ...
@overload
def asarray(a: ndarray, dtype: Type[_Float]) -> ndarray[_Float]: ...
@overload
def asarray(a: ndarray, dtype: Type[str_]) -> ndarray[str_]: ...

# the bool overload has to come before the int overload because bool is a subclass of int
@overload
def asarray(a: ndarray, dtype: Type[bool]) -> ndarray[bool_]: ...
@overload
def asarray(a: ndarray, dtype: Type[int]) -> ndarray[int64]: ...
@overload
def asarray(a: ndarray, dtype: Type[float]) -> ndarray[float64]: ...
@overload
def asarray(a: ndarray, dtype: Type[str]) -> ndarray[str_]: ...
@overload
def atleast_2d(ary: _Coercable) -> ndarray: ...
@overload
def atleast_2d(ar: _Coercable, *ary: _Coercable) -> List[ndarray]: ...
@overload
def ceil(a: _FloatObj) -> _FloatObj: ...
@overload
def ceil(a: ndarray[_Scalar]) -> ndarray[_Scalar]: ...
def clip(a: ndarray[_Scalar], a_min: _Scalar, a_max: _Scalar) -> ndarray[_Scalar]: ...
def concatenate(arrays: Sequence[_ArrayLike[_Scalar]], axis: _AxesType = ...) -> ndarray[_Scalar]: ...
def corrcoef(
    x: ndarray[_Scalar], y: Optional[ndarray[_Scalar]] = ..., rowvar: Optional[bool] = ...
) -> ndarray[float64]: ...
def cov(m: ndarray[_Scalar], rowvar: Optional[bool]) -> ndarray[float64]: ...
def diag(a: ndarray[_Scalar]) -> ndarray[_Scalar]: ...
def digitize(x: ndarray[_Scalar], bins: ndarray[_Scalar], right: bool = ...) -> ndarray[_Scalar]: ...
@overload
def divide(x1: float32, x2: float32) -> float32: ...
@overload
def divide(x1: _ScalarObj, x2: _ScalarObj) -> float64: ...
@overload
def divide(x1: ndarray[float32], x2: Union[ndarray[float32], float32]) -> ndarray[float32]: ...
@overload
def divide(x1: ndarray, x2: Union[ndarray, _ScalarObj]) -> ndarray[float64]: ...
@overload
def divide(x1: Sequence[_AnyNum], x2: _ScalarObj) -> ndarray[float64]: ...
@overload
def dot(x1: _Int, x2: _Int) -> _Int: ...
@overload
def dot(x1: ndarray, x2: ndarray) -> ndarray: ...
@overload
def exp(a: _ScalarObj) -> _ScalarObj: ...
@overload
def exp(a: ndarray[_Scalar]) -> ndarray[_Scalar]: ...
def expand_dims(a: ndarray[_Scalar], axis: _AxesType) -> ndarray[_Scalar]: ...
def fill_diagonal(a: ndarray[_Scalar], val: _FloatObj, wrap: bool = ...) -> None: ...
@overload
def floor(x: _FloatObj) -> _FloatObj: ...
@overload
def floor(x: ndarray[_Float]) -> ndarray[_Float]: ...
def hstack(tup: Union[List[ndarray[_Scalar]], Tuple[ndarray[_Scalar], ...]]) -> ndarray[_Scalar]: ...
def isclose(
    a: _ArrayLike, b: _ArrayLike, rtol: float = ..., atol: float = ..., equal_nan: bool = ...
) -> ndarray: ...
def in1d(
    ar1: ndarray[_Scalar], ar2: ndarray[_Scalar], assume_unique: bool = ..., inverse: bool = ...
) -> ndarray[bool_]: ...
def isin(element: Sequence[_Scalar], test_element: _Scalar) -> ndarray[_Scalar]: ...
@overload
def isnan(x: float64) -> bool: ...
@overload
def isnan(x: ndarray[_Scalar]) -> ndarray[bool_]: ...
@overload
def ix_(x: ndarray[_Scalar]) -> ndarray[_Scalar]: ...
@overload
def ix_(x1: ndarray[_Scalar], x2: ndarray[_Scalar]) -> Tuple[ndarray[_Scalar], ndarray[_Scalar]]: ...
@overload
def log(a: _FloatObj) -> _FloatObj: ...
@overload
def log(a: ndarray[_Scalar]) -> ndarray[_Scalar]: ...
@overload
def log2(a: _FloatObj) -> _FloatObj: ...
@overload
def log2(a: ndarray[_Scalar]) -> ndarray[_Scalar]: ...
@overload
def log10(a: _FloatObj) -> _FloatObj: ...
@overload
def log10(a: ndarray[_Scalar]) -> ndarray[_Scalar]: ...
def logical_and(x1: ndarray[bool_], x2: ndarray[bool_]) -> ndarray[bool_]: ...
def matmul(a: ndarray[_Scalar], b: ndarray[_Scalar]) -> ndarray[_Scalar]: ...
@overload
def max(a: ndarray[_Scalar], axis: None = ...) -> _Scalar: ...
@overload
def max(a: ndarray[_Scalar], axis: _AxesType, keepdims: bool = ...) -> ndarray[_Scalar]: ...
def maximum(a: ndarray[_Scalar], b: ndarray[_Scalar]) -> ndarray[_Scalar]: ...
@overload
def mean(a: ndarray[_Float]) -> _Float: ...
@overload
def mean(a: ndarray[_Float], axis: _AxesType, keepdims: bool = ...) -> ndarray[_Float]: ...
def median(
    a: ndarray,
    axis: _IntObj = ...,
    out: ndarray = ...,
    overwrite_input: bool = ...,
    keepdims: bool = ...,
) -> ndarray[float64]: ...
@overload
def min(a: ndarray[_Scalar], axis: None = ...) -> _Scalar: ...
@overload
def min(a: ndarray[_Scalar], axis: _AxesType, keepdims: bool = ...) -> ndarray[_Scalar]: ...
def minimum(a: ndarray[_Scalar], b: ndarray[_Scalar]) -> ndarray[_Scalar]: ...
@overload
def nanstd(a: ndarray[_Float]) -> _Float: ...
@overload
def nanstd(a: ndarray[_Float], axis: _AxesType, keepdims: bool = ...) -> ndarray[_Float]: ...
def nansum(a: ndarray[_Scalar]) -> ndarray[_Scalar]: ...
def nan_to_num(
    x: ndarray[_Scalar],
    copy: bool = ...,
    nan: _AnyNum = ...,
    posinf: _AnyNum = ...,
    neginf: _AnyNum = ...,
) -> ndarray[_Scalar]: ...
def nonzero(a: ndarray) -> Tuple[ndarray[int64], ...]: ...
def outer(a: ndarray[_Scalar], b: ndarray[_Scalar]) -> ndarray[_Scalar]: ...
@overload
def percentile(
    a: ndarray[_Scalar], q: _FloatObj, interpolation: _InterpolationType = ..., axis: _AxesType = ...
) -> _Scalar: ...
@overload
def percentile(
    a: ndarray[_Scalar],
    q: _ArrayLike,
    interpolation: _InterpolationType = ...,
    axis: _AxesType = ...,
) -> ndarray[_Scalar]: ...
def power(x1: ndarray[_Scalar], x2: Union[_AnyNum, ndarray[_Scalar]]) -> ndarray[_Scalar]: ...
@overload
def prod(a: ndarray[_Scalar], axis: None = ...) -> _Scalar: ...
@overload
def prod(a: ndarray[_Scalar], axis: _AxesType, keepdims: bool = ...) -> ndarray[_Scalar]: ...
def ravel(a: ndarray[_Scalar]) -> ndarray[_Scalar]: ...
def reshape(a: ndarray[_Scalar], newshape: _ShapeType) -> ndarray[_Scalar]: ...
def round(a: ndarray[_Scalar], decimals: _IntObj = ...) -> ndarray[_Scalar]: ...
def save(
    file: Union[str, Path], arr: ndarray, allow_pickle: bool = ..., fix_imports: bool = ...
) -> None: ...
@overload
def searchsorted(a: ndarray[_Scalar], v: _Scalar, side: str = ...) -> int64: ...
@overload
def searchsorted(a: ndarray[_Scalar], v: ndarray[_Scalar], side: str = ...) -> ndarray[int64]: ...
def setdiff1d(
    ar1: ndarray[_Scalar], ar2: ndarray[_Scalar], assume_unique: bool = ...
) -> ndarray[_Scalar]: ...
def sign(x: ndarray[_Scalar]) -> ndarray[_Scalar]: ...
def sort(a: ndarray[_Scalar]) -> ndarray[_Scalar]: ...
def split(
    ary: ndarray[_Scalar], indices_or_sections: Union[int, List[int]], axis: int = ...
) -> List[ndarray[_Scalar]]: ...
def square(x: ndarray[_Scalar]) -> ndarray[_Scalar]: ...
def squeeze(a: ndarray[_Scalar], axis: _AxesType = ...) -> ndarray[_Scalar]: ...
@overload
def sqrt(a: float) -> float: ...
@overload
def sqrt(a: ndarray) -> ndarray[float64]: ...
def stack(arrays: List[ndarray[_Scalar]], axis: _AxesType = ...) -> ndarray[_Scalar]: ...
@overload
def std(a: ndarray[_Float]) -> _Float: ...
@overload
def std(a: ndarray[_Float], axis: _AxesType, keepdims: bool = ...) -> ndarray[_Float]: ...
def subtract(
    x1: ndarray[_Scalar], x2: ndarray[_Scalar], axis: Optional[int] = ...
) -> ndarray[_Scalar]: ...
@overload
def sum(a: ndarray[_Scalar], axis: None = ...) -> _Scalar: ...
@overload
def sum(a: ndarray[_Scalar], axis: _AxesType, keepdims: bool = ...) -> ndarray[_Scalar]: ...
def take(a: ndarray[_Scalar], indices: ndarray[_Int], axis: _AxesType = ...) -> ndarray[_Scalar]: ...
def take_along_axis(
    arr: ndarray[_Scalar], indices: ndarray[_Int], axis: _AxesType = ...
) -> ndarray[_Scalar]: ...
def tile(a: ndarray[_Scalar], reps: Union[_NestedList[int], ndarray[_Int]]) -> ndarray[_Scalar]: ...
def trace(a: ndarray[_Scalar]) -> _Scalar: ...
def transpose(a: ndarray[_Scalar]) -> ndarray[_Scalar]: ...
def tril(m: ndarray[_Scalar], k: Optional[int] = ...) -> ndarray[_Scalar]: ...
def tril_indices(n: _IntObj, k: _IntObj = ..., m: _IntObj = ...) -> Tuple[ndarray, ndarray]: ...
def triu(m: ndarray[_Scalar], k: Optional[int] = ...) -> ndarray[_Scalar]: ...
@overload
def unique(a: ndarray[_Scalar], axis: Optional[int] = ...) -> ndarray[_Scalar]: ...
@overload
def unique(
    a: ndarray[_Scalar], return_counts: bool = ..., axis: Optional[int] = ...
) -> Tuple[ndarray[_Scalar], ndarray[_Scalar]]: ...
@overload
def unique(
    a: ndarray[_Scalar], return_inverse: bool = ..., axis: Optional[int] = ...
) -> Tuple[ndarray[_Scalar], ndarray[_Scalar]]: ...
def vstack(tup: Sequence[ndarray[_Scalar]]) -> ndarray[_Scalar]: ...
@overload
def where(condition: _ConditionType, x: ndarray[_Scalar], y: ndarray[_Scalar]) -> ndarray[_Scalar]: ...
@overload
def where(condition: _ConditionType, x: _ScalarLike, y: ndarray[_Scalar]) -> ndarray[_Scalar]: ...
@overload
def where(condition: _ConditionType, x: ndarray[_Scalar], y: _ScalarLike) -> ndarray[_Scalar]: ...
@overload
def where(condition: _ConditionType, x: _Scalar, y: _Scalar) -> ndarray[_Scalar]: ...
@overload
def where(condition: _ConditionType, x: int, y: int) -> ndarray[int64]: ...
@overload
def where(condition: _ConditionType, x: float, y: float) -> ndarray[float64]: ...
@overload
def where(condition: _ConditionType) -> Tuple[ndarray[int64], ...]: ...

#
# Saving methods
#
def savetxt(
    fname: str,
    X: ndarray,
    *,
    header: str = ...,
    delimiter: str = ...,
    newline: str = ...,
    comments: str = ...,
) -> None: ...
def savez(file: Path, *args: ndarray, **kwds: ndarray) -> None: ...
def savez_compressed(file: Path, *args: ndarray, **kwds: ndarray) -> None: ...

#
# weird classes
#
class matrix:
    def __init__(self, data: Union[List, str], dtype: Type[_Scalar] = ..., copy: bool = ...): ...
    def reshape(self, shape: _ShapeType) -> matrix: ...

class finfo:
    def __init__(self, dtype: Union[_FloatObj, Type[_ScalarObj]]): ...
    @property
    def eps(self) -> _FloatObj: ...
    @property
    def resolution(self) -> _FloatObj: ...
    @property
    def min(self) -> _FloatObj: ...
    @property
    def max(self) -> _FloatObj: ...
    @property
    def dtype(self) -> Type[_ScalarObj]: ...

#
# Specific values
#
e: float
inf: float
nan: float
NaN: float
NAN: float
pi: float

# Local Variables:
# blacken-line-length: 100
# blacken-allow-py36: t
# blacken-skip-string-normalization: t
# End:
