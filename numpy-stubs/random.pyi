from typing import Iterable, List, Optional, Sequence, Tuple, TypeVar, Union, overload

from . import (
    _ArrayLike,
    _Scalar,
    _Float,
    _FloatObj,
    _Int,
    _IntObj,
    _ShapeType,
    float64,
    int64,
    ndarray,
)

_T = TypeVar("_T")
@overload
def binomial(n: _IntObj, p: _FloatObj) -> _Int: ...
@overload
def binomial(n: _IntObj, p: _FloatObj, size: _IntObj) -> ndarray[_Int]: ...
@overload
def binomial(n: _IntObj, p: _ArrayLike[_Float], size: ndarray[_Int] = ...,) -> ndarray[_Int]: ...
@overload
def binomial(n: _ArrayLike[_Int], p: _FloatObj, size: ndarray[_Int] = ...,) -> ndarray[_Int]: ...
@overload
def binomial(
    n: _ArrayLike[_Int], p: _ArrayLike[_Float], size: ndarray[_Int] = ...,
) -> ndarray[_Int]: ...
@overload
def choice(a: _IntObj) -> _IntObj: ...
@overload
def choice(a: _Int, size: int) -> ndarray[_Int]: ...
@overload
def choice(a: int, size: int) -> ndarray[int64]: ...
@overload
def choice(a: _IntObj, size: _IntObj, replace: bool) -> ndarray[int64]: ...
@overload
def choice(
    a: List[_T], p: Union[List[_FloatObj], ndarray[_Float]] = ..., replace: bool = ...
) -> _T: ...
@overload
def choice(
    a: range, size: _IntObj, replace: bool = ..., p: Union[List[_FloatObj], ndarray[_Float]] = ...
) -> ndarray[int64]: ...
@overload
def choice(
    a: range, *, replace: bool = ..., p: Union[List[_FloatObj], ndarray[_Float]] = ...
) -> int64: ...
@overload
def choice(
    a: ndarray[_Scalar],
    size: _IntObj,
    replace: bool = ...,
    p: Union[List[_FloatObj], ndarray[_Float]] = ...,
) -> ndarray[_Scalar]: ...
@overload
def choice(
    a: ndarray[_Scalar], *, replace: bool = ..., p: Union[List[_FloatObj], ndarray[_Float]] = ...
) -> _Scalar: ...
def dirichlet(alpha: ndarray[_Scalar], size: _IntObj = ...) -> ndarray[_Scalar]: ...
@overload
def exponential(scale: _FloatObj) -> _Float: ...
@overload
def exponential(scale: _FloatObj, size: Sequence[_IntObj]) -> ndarray[float64]: ...
@overload
def exponential(scale: Sequence[_FloatObj], size: Sequence[_IntObj]) -> ndarray[float64]: ...
def geometric(p: float, size: _IntObj) -> ndarray[float64]: ...
def get_state() -> Tuple[str, ndarray[_Int], _IntObj, _IntObj, _FloatObj]: ...
def normal(loc: float, scale: float, size: Union[int, Tuple[int, ...]]) -> ndarray[float64]: ...
@overload
def permutation(size: int) -> ndarray[int64]: ...
@overload
def permutation(size: Iterable[_Scalar]) -> ndarray[_Scalar]: ...
def randn(*args: int) -> ndarray[_Float]: ...
@overload
def randint(low: int, high: int = ...) -> int64: ...
@overload
def randint(low: int, size: Tuple[int, ...], high: int = ...) -> ndarray[int64]: ...
@overload
def randint(low: int, size: int, high: int = ...) -> ndarray[int64]: ...
def seed(s: int) -> None: ...
def set_state(state: Tuple[str, ndarray[_Int], _IntObj, _IntObj, _FloatObj]) -> None: ...
def shuffle(x: ndarray) -> None: ...
@overload
def uniform() -> float64: ...
@overload
def uniform(size: _ShapeType) -> ndarray: ...
@overload
def uniform(low: float, high: float, size: _ShapeType) -> ndarray: ...

class RandomState:
    def __init__(self, seed: int = ...): ...
    def multivariate_normal(
        self,
        mean: ndarray[_Scalar] = ...,
        cov: ndarray[_Scalar] = ...,
        size: Optional[_ShapeType] = ...,
    ) -> ndarray[_Scalar]: ...
    def normal(
        self,
        loc: Union[float, ndarray[_Scalar]] = ...,
        scale: Union[float, ndarray[_Scalar]] = ...,
        size: Optional[_ShapeType] = ...,
    ) -> ndarray[_Scalar]: ...
    def permutation(self, size: int) -> ndarray[int64]: ...
    def shuffle(self, x: ndarray) -> None: ...
    def uniform(self, size: _ShapeType) -> ndarray: ...
    @overload
    def choice(self, a: _IntObj) -> _IntObj: ...
    @overload
    def choice(self, a: _Int, size: int) -> ndarray[_Int]: ...
    @overload
    def choice(self, a: int, size: int) -> ndarray[int64]: ...
    @overload
    def choice(self, a: _IntObj, size: _IntObj, replace: bool) -> ndarray[int64]: ...
    @overload
    def choice(
        self, a: List[_T], p: Union[List[_FloatObj], ndarray[_Float]] = ..., replace: bool = ...
    ) -> _T: ...
    @overload
    def choice(
        self,
        a: range,
        size: _IntObj,
        replace: bool = ...,
        p: Union[List[_FloatObj], ndarray[_Float]] = ...,
    ) -> ndarray[int64]: ...
    @overload
    def choice(
        self, a: range, *, replace: bool = ..., p: Union[List[_FloatObj], ndarray[_Float]] = ...
    ) -> int64: ...
    @overload
    def choice(
        self,
        a: ndarray[_Scalar],
        size: _IntObj,
        replace: bool = ...,
        p: Union[List[_FloatObj], ndarray[_Float]] = ...,
    ) -> ndarray[_Scalar]: ...
    @overload
    def choice(
        self,
        a: ndarray[_Scalar],
        *,
        replace: bool = ...,
        p: Union[List[_FloatObj], ndarray[_Float]] = ...,
    ) -> _Scalar: ...
